
class destructor topic 6/2/2023
i got this on https://en.cppreference.com/w/cpp/language/destructor

Destructors
 C++ C++ language Classes 
A destructor is a special member function that is called when the lifetime of an object ends. 
The purpose of the destructor is to free the resources that the object may have acquired 
during its lifetime.

A destructor must not be a coroutine.

(since C++20)

Syntax
~ class-name ();	(1)	
virtual ~ class-name ();	(2)	
decl-specifier-seq ﻿(optional) ~ class-name () = default;	(3)	(since C++11)
decl-specifier-seq ﻿(optional) ~ class-name () = delete;	(4)	(since C++11)
attr ﻿(optional) decl-specifier-seq ﻿(optional) id-expression ( void(optional) )
except ﻿(optional) attr ﻿(optional) requires-clause ﻿(optional);	(5https://en.cppreference.com/w/cpp/language/destructor)	

1) Typical declaration of a prospective (since C++20) destructor.
2) Virtual destructor is usually required in a base class.
3) Forcing a destructor to be generated by the compiler.
4) Disabling the implicit destructor.
5) Formal syntax of a prospective (since C++20) destructor declaration.


decl-specifier-seq	-	friend, inline, virtual, constexpr, consteval (since C++20)

id-expression
	within a class definition, the symbol ~ followed by the class-name. Within a class template, 
the symbol ~ followed by the name of the current instantiation of the template. At namespace scope or
 in a friend declaration within a different class, nested-name-specifier followed by the symbol ~
 followed by the class-name which is the same class as the one named by the nested-name-specifier. 
In any case, the name must be the actual name of the class or template, and not a typedef. The entire
id-expression may be surrounded by parentheses which do not change its meaning.

attr
(since C++11) sequence of any number of attributes

except	-
exception specification as in any function declaration
If no exception specification is explicitly provided, the exception specification is considered to
 be one that would be used by the implicitly-declared destructor (see below). In most cases, this is 
noexcept(true). Thus a throwing destructor must be explicitly declared noexcept(false).
(since C++11)

requires-clause
	(since C++20) requires-clause that declares the associated constraints for the prospective 
destructor, which must be satisfied in order for the prospective destructor to be selected as the 
destructor

Explanation
The destructor is called whenever an object's lifetime ends, which includes

program termination, for objects with static storage duration
thread exit, for objects with thread-local storage duration
(since C++11)
end of scope, for objects with automatic storage duration and for temporaries whose life was extended by
 binding to a reference
delete-expression, for objects with dynamic storage duration
end of the full expression, for nameless temporaries
stack unwinding, for objects with automatic storage duration when an exception escapes their block, 
uncaught.

The destructor may also be called directly, e.g. to destroy an object that was constructed using 
placement-new or through an allocator member function such as std::allocator::destroy(), to destroy an 
object that was constructed through the allocator. Note that calling a destructor directly for an 
ordinary object, such as a local variable, invokes undefined behavior when the destructor is called 
again, at the end of scope.

In generic contexts, the destructor call syntax can be used with an object of non-class type; this is 
known as pseudo-destructor call: see member access operator.


Virtual destructors
Deleting an object through pointer to base invokes undefined behavior unless the destructor in the base
class is virtual:

lass Base
{
public:
    virtual ~Base() {}
};
 
class Derived : public Base {};
 
Base* b = new Derived;
delete b; // safe

A common guideline is that a destructor for a base class must be either public and virtual or protected 
and nonvirtual



Pure virtual destructors
A prospective (since C++20) destructor may be declared pure virtual, for example in a base class which
needs to be made abstract, but has no other suitable functions that could be declared pure virtual. 
A pure virtual destructor must have a definition, since all base class destructors are always called
 when the derived class is destroyed:


class AbstractBase
{
public:
    virtual ~AbstractBase() = 0;
};
AbstractBase::~AbstractBase() {}
 
class Derived : public AbstractBase {};
 
// AbstractBase obj; // compiler error
Derived obj;         // OK


Exceptions
As any other function, a destructor may terminate by throwing an exception (this usually requires it 
to be explicitly declared noexcept(false)) (since C++11), however if this destructor happens to be 
called during stack unwinding, std::terminate is called instead.

Although std::uncaught_exception may sometimes be used to detect stack unwinding in progress, it is 
generally considered bad practice to allow any destructor to terminate by throwing an exception. This
 functionality is nevertheless used by some libraries, such as SOCI and Galera 3, which rely on the
 ability of the destructors of nameless temporaries to throw exceptions at the end of the full 
expression that constructs the temporary.

std::experimental::scope_success in Library fundamental TS v3 may have a potentially-throwing 
destructor, which throws an exception when the scope is exited normally and the exit function throws
 an exception.


#include <iostream>
 
struct A
{
    int i;
 
    A(int num) : i(num)
    {
        std::cout << "ctor a" << i << '\n';
    }
 
    ~A()
    {
        std::cout << "dtor a" << i << '\n';
    }
};
 
A a0(0);
 
int main()
{
    A a1(1);
    A* p;
 
    { // nested scope
        A a2(2);
        p = new A(3);
    } // a2 out of scope
 
    delete p; // calls the destructor of a3
}

Output:

ctor a0
ctor a1
ctor a2
ctor a3
dtor a2
dtor a3
dtor a1
dtor a0









